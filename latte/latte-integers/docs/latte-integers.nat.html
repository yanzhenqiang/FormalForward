<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-integers.nat documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-integers</span> <span class="project-version">0.12.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-integers</span></div></div></li><li class="depth-2 branch"><a href="latte-integers.divides.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>divides</span></div></a></li><li class="depth-2 branch"><a href="latte-integers.int.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>int</span></div></a></li><li class="depth-2 branch"><a href="latte-integers.minus.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>minus</span></div></a></li><li class="depth-2 branch current"><a href="latte-integers.nat.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nat</span></div></a></li><li class="depth-2 branch"><a href="latte-integers.ord.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ord</span></div></a></li><li class="depth-2 branch"><a href="latte-integers.plus.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plus</span></div></a></li><li class="depth-2 branch"><a href="latte-integers.rec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rec</span></div></a></li><li class="depth-2"><a href="latte-integers.times.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>times</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-integers.nat.html#var-int-split"><div class="inner"><span>int-split</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-int-split-alt"><div class="inner"><span>int-split-alt</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-int-split-elim"><div class="inner"><span>int-split-elim</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-int-split-elim-rule"><div class="inner"><span>int-split-elim-rule</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-int-split-zero"><div class="inner"><span>int-split-zero</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat"><div class="inner"><span>nat</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-case"><div class="inner"><span>nat-case</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-induct"><div class="inner"><span>nat-induct</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-split"><div class="inner"><span>nat-split</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-succ"><div class="inner"><span>nat-succ</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-succ-injective"><div class="inner"><span>nat-succ-injective</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-succ-prop"><div class="inner"><span>nat-succ-prop</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-zero"><div class="inner"><span>nat-zero</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-zero-has-no-pred"><div class="inner"><span>nat-zero-has-no-pred</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-nat-zero-is-not-succ"><div class="inner"><span>nat-zero-is-not-succ</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative"><div class="inner"><span>negative</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-nat"><div class="inner"><span>negative-nat</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-not-zero"><div class="inner"><span>negative-not-zero</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-pred"><div class="inner"><span>negative-pred</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-pred-split"><div class="inner"><span>negative-pred-split</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-pred-split-conv"><div class="inner"><span>negative-pred-split-conv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-pred-split-equiv"><div class="inner"><span>negative-pred-split-equiv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-negative-pred-zero"><div class="inner"><span>negative-pred-zero</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive"><div class="inner"><span>positive</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-conv"><div class="inner"><span>positive-conv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-nat-split"><div class="inner"><span>positive-nat-split</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-not-zero"><div class="inner"><span>positive-not-zero</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ"><div class="inner"><span>positive-succ</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-conv"><div class="inner"><span>positive-succ-conv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-equiv"><div class="inner"><span>positive-succ-equiv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-split"><div class="inner"><span>positive-succ-split</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-split-conv"><div class="inner"><span>positive-succ-split-conv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-split-equiv"><div class="inner"><span>positive-succ-split-equiv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-succ-strong"><div class="inner"><span>positive-succ-strong</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-positive-zero-conv"><div class="inner"><span>positive-zero-conv</span></div></a></li><li class="depth-1"><a href="latte-integers.nat.html#var-zero-is-not-one"><div class="inner"><span>zero-is-not-one</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-integers.nat</h1><div class="doc"><div class="markdown"><p>The natural integers in ℕ as a subset of ℤ.</p></div></div><div class="public anchor" id="var-int-split"><h3>int-split</h3><div class="usage"><code>(int-split [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(or (or (= n zero) (positive n)) (negative n))
</code></pre>
<p><strong>Theorem</strong>: The tripartition property about integers.</p></div></div></div><div class="public anchor" id="var-int-split-alt"><h3>int-split-alt</h3><div class="usage"><code>(int-split-alt [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(or (elem n nat) (not (elem n nat)))
</code></pre>
<p><strong>Theorem</strong>: An alternative split principle for integers (or a constructive excluded middle principle, so to speak).</p></div></div></div><div class="public anchor" id="var-int-split-elim"><h3>int-split-elim</h3><div class="usage"><code>(int-split-elim [n int] [pz (==&gt; (= n zero) A)] [ppos (==&gt; (positive n) A)] [pneg (==&gt; (negative n) A)])</code></div><div class="doc"><div class="markdown"><pre><code>A
</code></pre>
<p><strong>Theorem</strong>: An elimination princile for integers, cf. <a href="latte-integers.nat.html#var-int-split-elim-rule">int-split-elim-rule</a>.</p></div></div></div><div class="public anchor" id="var-int-split-elim-rule"><h3>int-split-elim-rule</h3><div class="usage"><code>(int-split-elim-rule [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [n int]
 (==&gt; (==&gt; (= n zero) A) (==&gt; (positive n) A) (==&gt; (negative n) A) A))
</code></pre>
<p><strong>Theorem</strong>: An elimination principle for integers.</p></div></div></div><div class="public anchor" id="var-int-split-zero"><h3>int-split-zero</h3><div class="usage"><code>(int-split-zero [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(or (= n zero) (not (= n zero)))
</code></pre>
<p><strong>Theorem</strong>: Yet another split principle for integers.</p></div></div></div><div class="public anchor" id="var-nat"><h3>nat</h3><div class="usage"><code>(nat)</code></div><div class="doc"><div class="markdown"><pre><code>(lambda
 [x int]
 (forall
  [P (==&gt; int :type)]
  (==&gt; (and (P zero) (nat-succ-prop P)) (P x))))
</code></pre>
<p><strong>Definition</strong>: The subset of natural integers.</p></div></div></div><div class="public anchor" id="var-nat-case"><h3>nat-case</h3><div class="usage"><code>(nat-case [P (==&gt; int :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (P zero)
 (forall-in [k nat] (P (succ k)))
 (forall-in [n nat] (P n)))
</code></pre>
<p><strong>Theorem</strong>: Case analysis for natural numbers.</p></div></div></div><div class="public anchor" id="var-nat-induct"><h3>nat-induct</h3><div class="usage"><code>(nat-induct [P (==&gt; int :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (P zero)
 (forall [x int] (==&gt; (elem x nat) (P x) (P (succ x))))
 (forall [x int] (==&gt; (elem x nat) (P x))))
</code></pre>
<p><strong>Theorem</strong>: The induction principle for natural integers. This is the third Peano axiom but it can be derived from <a href="latte-integers.int.html#var-int-induct">int-induct</a>.</p></div></div></div><div class="public anchor" id="var-nat-split"><h3>nat-split</h3><div class="usage"><code>(nat-split)</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [n nat] (or (= n zero) (positive n)))
</code></pre>
<p><strong>Theorem</strong>: A natural number is either zero or it is positive</p></div></div></div><div class="public anchor" id="var-nat-succ"><h3>nat-succ</h3><div class="usage"><code>(nat-succ [x int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x nat) (elem (succ x) nat))
</code></pre>
<p><strong>Theorem</strong>: The successor of a natural integer is a natural integer.</p></div></div></div><div class="public anchor" id="var-nat-succ-injective"><h3>nat-succ-injective</h3><div class="usage"><code>(nat-succ-injective)</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [x y int]
 (==&gt; (elem x nat) (elem y nat) (= (succ x) (succ y)) (= x y)))
</code></pre>
<p><strong>Theorem</strong>: Successor is injective, the second Peano ‘axiom’ here a simple consequence of <a href="latte-integers.int.html#var-succ-injective">succ-injective</a>.</p></div></div></div><div class="public anchor" id="var-nat-succ-prop"><h3>nat-succ-prop</h3><div class="usage"><code>(nat-succ-prop [P (==&gt; int :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [y int] (==&gt; (P y) (P (succ y))))
</code></pre>
<p><strong>Definition</strong>: A property verified by all successors of natural integers.</p></div></div></div><div class="public anchor" id="var-nat-zero"><h3>nat-zero</h3><div class="usage"><code>(nat-zero)</code></div><div class="doc"><div class="markdown"><pre><code>(elem zero nat)
</code></pre>
<p><strong>Theorem</strong>: Zero is a natural integer.</p></div></div></div><div class="public anchor" id="var-nat-zero-has-no-pred"><h3>nat-zero-has-no-pred</h3><div class="usage"><code>(nat-zero-has-no-pred)</code></div><div class="doc"><div class="markdown"><pre><code>(not (elem (pred zero) nat))
</code></pre>
<p><strong>Axiom</strong>: An important axiom of the natural integer subset wrt. <a href="latte-integers.int.html#var-pred">pred</a>.</p></div></div></div><div class="public anchor" id="var-nat-zero-is-not-succ"><h3>nat-zero-is-not-succ</h3><div class="usage"><code>(nat-zero-is-not-succ)</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x int] (==&gt; (elem x nat) (not (= (succ x) zero))))
</code></pre>
<p><strong>Theorem</strong>: Zero is not a successor of a natural integer.</p>
<p>This is the first Peano ‘axiom’ (here theorem, based  on integers) for natural integers.</p></div></div></div><div class="public anchor" id="var-negative"><h3>negative</h3><div class="usage"><code>(negative [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(not (elem n nat))
</code></pre>
<p><strong>Definition</strong>: The integer <code>n</code> is strictly negative.</p></div></div></div><div class="public anchor" id="var-negative-nat"><h3>negative-nat</h3><div class="usage"><code>(negative-nat)</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [n nat] (not (negative n)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-negative-not-zero"><h3>negative-not-zero</h3><div class="usage"><code>(negative-not-zero)</code></div><div class="doc"><div class="markdown"><pre><code>(not (negative zero))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-negative-pred"><h3>negative-pred</h3><div class="usage"><code>(negative-pred [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (negative n) (negative (pred n)))
</code></pre>
<p><strong>Theorem</strong>: Negative predecessors.</p></div></div></div><div class="public anchor" id="var-negative-pred-split"><h3>negative-pred-split</h3><div class="usage"><code>(negative-pred-split [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (negative (pred n)) (or (= n zero) (negative n)))
</code></pre>
<p><strong>Theorem</strong>: Splitting of a predecessor.</p></div></div></div><div class="public anchor" id="var-negative-pred-split-conv"><h3>negative-pred-split-conv</h3><div class="usage"><code>(negative-pred-split-conv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or (= n zero) (negative n)) (negative (pred n)))
</code></pre>
<p><strong>Theorem</strong>: An auxiliary theorem for the predecessor.</p></div></div></div><div class="public anchor" id="var-negative-pred-split-equiv"><h3>negative-pred-split-equiv</h3><div class="usage"><code>(negative-pred-split-equiv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (negative (pred n)) (or (= n zero) (negative n)))
</code></pre>
<p><strong>Theorem</strong>: The conjunction of <a href="latte-integers.nat.html#var-negative-pred-split">negative-pred-split</a> and <a href="latte-integers.nat.html#var-negative-pred-split-conv">negative-pred-split-conv</a>.</p></div></div></div><div class="public anchor" id="var-negative-pred-zero"><h3>negative-pred-zero</h3><div class="usage"><code>(negative-pred-zero)</code></div><div class="doc"><div class="markdown"><pre><code>(negative (pred zero))
</code></pre>
<p><strong>Theorem</strong>: The predecessor of zero is negative.</p></div></div></div><div class="public anchor" id="var-positive"><h3>positive</h3><div class="usage"><code>(positive [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(elem (pred n) nat)
</code></pre>
<p><strong>Definition</strong>: The integer <code>n</code> is strictly positive.</p></div></div></div><div class="public anchor" id="var-positive-conv"><h3>positive-conv</h3><div class="usage"><code>(positive-conv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (positive n) (elem n nat))
</code></pre>
<p><strong>Theorem</strong>: A positive natural number is (obiously) a natural number</p></div></div></div><div class="public anchor" id="var-positive-nat-split"><h3>positive-nat-split</h3><div class="usage"><code>(positive-nat-split)</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [x nat] (==&gt; (not (= x zero)) (positive x)))
</code></pre>
<p><strong>Theorem</strong>: Any non-zero natural number is positive.</p></div></div></div><div class="public anchor" id="var-positive-not-zero"><h3>positive-not-zero</h3><div class="usage"><code>(positive-not-zero)</code></div><div class="doc"><div class="markdown"><pre><code>(not (positive zero))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-positive-succ"><h3>positive-succ</h3><div class="usage"><code>(positive-succ [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem n nat) (positive (succ n)))
</code></pre>
<p><strong>Theorem</strong>: The successor of a natural number is positive.</p></div></div></div><div class="public anchor" id="var-positive-succ-conv"><h3>positive-succ-conv</h3><div class="usage"><code>(positive-succ-conv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (positive (succ n)) (elem n nat))
</code></pre>
<p><strong>Theorem</strong>: A successor of a positive natural number is (obiously) a natural number</p></div></div></div><div class="public anchor" id="var-positive-succ-equiv"><h3>positive-succ-equiv</h3><div class="usage"><code>(positive-succ-equiv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (positive (succ n)) (elem n nat))
</code></pre>
<p><strong>Theorem</strong>: A positive number is a natural number.</p></div></div></div><div class="public anchor" id="var-positive-succ-split"><h3>positive-succ-split</h3><div class="usage"><code>(positive-succ-split [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (positive (succ n)) (or (= n zero) (positive n)))
</code></pre>
<p><strong>Theorem</strong>: A positive successor can split.</p></div></div></div><div class="public anchor" id="var-positive-succ-split-conv"><h3>positive-succ-split-conv</h3><div class="usage"><code>(positive-succ-split-conv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or (= n zero) (positive n)) (positive (succ n)))
</code></pre>
<p><strong>Theorem</strong>: The converse of <a href="latte-integers.nat.html#var-positive-succ-split">positive-succ-split</a>.</p></div></div></div><div class="public anchor" id="var-positive-succ-split-equiv"><h3>positive-succ-split-equiv</h3><div class="usage"><code>(positive-succ-split-equiv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (positive (succ n)) (or (= n zero) (positive n)))
</code></pre>
<p><strong>Theorem</strong>: The conjunction of <a href="latte-integers.nat.html#var-positive-succ-split">positive-succ-split</a> and <a href="latte-integers.nat.html#var-positive-succ-split-conv">positive-succ-split-conv</a>.</p></div></div></div><div class="public anchor" id="var-positive-succ-strong"><h3>positive-succ-strong</h3><div class="usage"><code>(positive-succ-strong [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (positive n) (positive (succ n)))
</code></pre>
<p><strong>Theorem</strong>: The successor of a positive is positive.</p></div></div></div><div class="public anchor" id="var-positive-zero-conv"><h3>positive-zero-conv</h3><div class="usage"><code>(positive-zero-conv [n int])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or (= n zero) (positive n)) (elem n nat))
</code></pre>
<p><strong>Theorem</strong>: A positive or null number is … natural</p></div></div></div><div class="public anchor" id="var-zero-is-not-one"><h3>zero-is-not-one</h3><div class="usage"><code>(zero-is-not-one)</code></div><div class="doc"><div class="markdown"><pre><code>(not (= one zero))
</code></pre>
<p><strong>Theorem</strong>: A direct consequence of <a href="latte-integers.nat.html#var-nat-zero-is-not-succ">nat-zero-is-not-succ</a>.</p></div></div></div></div></body></html>